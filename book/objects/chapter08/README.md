# chapter08. 의존성 관리하기

요구사항의 변경은 의존성의 유무/결합도의 강약에 따라 변경해야 될 코드의 양과 변경된 코드의 질이 결정된다. 그러나 대부분의 클래스들은 협력관계에 있기 때문에 의존성이 존재한다.  설계시, 의존성을 약한(느슨한) 결합도로 유지하기 위해서는 협력관계의 클래스들 간의 컨텍스트 독립성을 보장해야 한다. 컨텍스트 독립성을 보장하기 위해서는 여러 추상화 기법들을 통하여 보장하는 것이 좋다.

- 객체지향의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다. → 객체지향 설계: 의존성 관리 및 객체의 의존성을 정리하는 기술

# 의존성

1. 실행시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
2. 구현시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
3. 의존성은 방향성을 가지며, 항상 단방향
4. 의존되는 요소가 변경될 때, 의존하는 요소도 함께 변경될 수 있음을 의미
5. 의존성 전이(transitive dependency)
    1. 의존성의 실제 전이여부는 변경의 방향 & 캡슐화의 정도에 따라 다름
    2. 직접의존성(direct dependency) - 직접적인 의존 A→B
    3. 간접의존성(indirect dependency) - 간접적인 의존 A→B→C :: C는 A에게 간접적으로 의존
6. 런타임 의존성(run-time dependency) - 추상화를 통한 의존성, 컴파일타임에는 어떤 객체에 의존적인지 알 수 없음(abstract class or interface 로 의존관계 설정)/
    1. 실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 코드가 좀 더 유연해진다.
7. 컴파일타임 의존성(compile-time dependency) - 코드 자체를 의미
- compile-time 의존성과 run-time 의존성은 거리가 멀 수록 설계가 유연해지고 재사용 가능해진다.
1. 컨텍스트 독립성(context independent) : 클래스가 특정 context에 강하게 결합될수록 단른 context에서 사용하기는 더 어려워지므로, 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 수월해짐.(즉 어디에서 쓰일지에 대한 최소한의 정보만 가지고 있는 것)
2. 의존성 해결
    1. 객체를 생성하는 시점에 생성자를 통한 의존성 해결
    2. 객체 생성 후 setter 메서드를 통한 의존성 해결
    3. 메서드 실행시 인자를 이용해서 의존성 해결

## 유연한 설계

1. 의존성과 결합도 : 의존성은 객체들의 협력을 가능하게 만드는 매체라는 관점에서는 바람직하지만, 의존성이 과하면(의존성의 정도) 문제가 될 수 있다.
    - 바람직한 의존성은 재사용성과 고나련이 있다. 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못한 것이다. 어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.
    - 바람직한 의존성 = 컨텍스트에 독립적인 의존성
    - 결합도
        - 느슨한 결합도(loose coupling) , 약한 결합도(weak coupling) ↔ 단단한 결합도(tight coupling), 강한 결합도(strong coupling)
2. 지식이 결합을 낳는다.
    - 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다. (알고있는 지식의 양과 결합도는 반비례한다) → 추상화를 이용해서 알고있는 지식의 양을 최소한으로 할 수 있다.
3. 추상화에 의존하라 : 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
    - 구체 클레스 의존성(concrete class dependency)
    - 추상 클래스 의존성(abstract class dependency)
    - 인터페이스 의존성(interface dependency)
    - 의존하는 대상이 더 추상적일수록 결합도는 낮아진다.
4. 명시적인 의존성 (explicit dependency) : 모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다.
    - 숨겨진 의존성(hidden dependency) : 의존성이 퍼블릭 인터페이스에 표현되지 않는 경우. → 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부현을 직접변경하는 등 재사용성이 현저히 낮아지므로 의존성을 내부구현에 숨겨두어서는 안된다.
5. new는 해롭다.
    1. new연산자를 사용하기 위해서는 구체클래스의 이름을 직접 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
    2. new연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다. 따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나므로 결합도가 높아진다.
    3. 해결방법 : 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리 → 외부(클라이언트)로 부터 생성된 인스턴스를 사용.
6. 가끔은 new를 이용해서 생성해도 무방하다. → 기본객체를 생성하는 생성자를 추가하고, 이 생성자에 생성된 인스턴스를 파라미터로 받는 생성자를 체이닝
7. 표준클래스에 대한 의존은 변경의 가능성이 현저히 낮으므로 6,7과 상관없다.
- 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용가능한 설계가 가진 특징.
- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합하므로써 새로운 행동을 이끌어낼 수 있는 설계. 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계가 훌룡한 객체지향 설계이다. 이러한 설계를 창조하는데 있어서의 핵심은 의존성을 관리하는 것이다. → 시스템을 ‘선언적인 정의’의 방식으로 구축하면 방법(how)이 아니라 목적(what)에 집중할 수 있어서 시스템의 행위를 변경하기가 더 쉽다.