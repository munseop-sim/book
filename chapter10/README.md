# chapter10. 상속과 코드 재사용

코드의 재사용

1. 상속 : 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현기법이다.
2. 합성 : 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법

### 상속을 위한 경고

1. 자식클래스의 메서드 안에서 super 참조를 이용해 부모클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거할 수 있는 방법을 찾아서 결합도를 제거해야 한다.
2. 상속받은 부모클랫의 메서드가 자식클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
3. 자식클래스가 부모클랫의 메서드를 오버라이딩할 경우 부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다.
4. 클래스를 상속하면 결합도로 인해 자식클래스와 부모클랫의 구현을 영원히 변경하지 않거나, 자식클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

### 1. 상속과 중복코드

- DRY(Don’t Repeat Yourself) 원칙 : 모든 지싱은 시스템 내에서 단일하고 애매하지 않고 정말로 믿을 만한 표현양식을 가져야 한다.
  - **Once and Only Once원칙** 또는 **Single-Point Conrol원칙** 이라고도 함.
- 최초 요구사항으로 작성된 코드에서 변경되거나 추가된 요구사항으로 인해 기존코드를 활용하여 중복해서 작성하게 되면, 작성된 코드는 또 다시 다른 요구사항으로 인해 중복의 중복코드로 발생할 가능성이 높아진다.  이렇게 작성된 코드는 유지보수가 어려워지고 전체적인 코드의 통일성도 깨지기 쉽다. 또한 이를 어설프게 상속을 이용해서 중복코드를 제거할때에는 부모클래스에 강하게 결합될 가능성도 높아진다.

### 2. 취약한 기반 클래스 문제

- 취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)
  - 상속을 사용한다면 피할 수 없는 OOP의 근본적인 취약성 : 핵심적인 기반 클래스에 대한 단순한 변경이 전체 프로그램을 불안정한 상태로 만들어버릴 수 있다.
  - 상속관계를 추가할수록 전체 시스템의 결합도가 높아진다.
  - 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵다.
  - 캡슐화를 약화시키고 결합도를 높인다.
  - 객체지향은 캡슐화를 통한 변경의 통제인데, 상속은 코드의 재사용을 위해 캡슐화의 잠점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.
- 불필요한 인터페이스 상속문제
  - 자바초기 버전의 사례
    1. Vector클래스를 상속받은 Stack 클래스의 사례 :: Vector의 add,remove,get 오퍼레이션을 Stack에서도 호출이 가능했다. → stack의 규칙 무시
    2. Hashtable 클래스를 상속받은 Properties 클래스의 사례 :: Hashtable의 put을 이용하면 String이외의 타입도 키로 지정가능하나, Properties는 String타입만 키로 지정이 가능하다. 그러나 Properites.put(new Object(), 123)메소드호출이 가능하나, Properties.getProperty(new Object())로 123을 읽으면 null이 반환됨. → 이는 Properties.getProperty메소드는 String이외의 Key는 null을 반환하도록 작성되었기 때문
  - 메서드 오버라이딩의 오작용 문제
    - 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야 한다. 그렇지 않은 경우에는 상속을 금지시켜야 한다.  → 메서드를 오버라이딩 가능한 메서드를 호출할 수있는 어떤 상황에 대해서도 문서화해야 한다.
    - 메서드를 오버라이딩하기 위해 문서화하는 행위는 내부구현을 공개하고 문서화해야 한다. 하지만 이는 캡술화를 위반하는 행위이다. 결론은 상속은 코드의 재사용을 위해 캡슐화를 희생해야 한다. 하지만 완벽한 캡슐화를 원한다면 코드의 재사용을 포기하거나, 상속 이외의 다른 방법을 사용해야 한다.
  - 부모클래스와 자식클래스의 동시 수정 문제
    - 서브클래스는 올바른 기능을 위해 슈퍼클랫의 세부적인 구현에 의존한다. 슈퍼클랫의 구현은 Release를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다. 결과적으로 슈퍼클래스와 작성자가 확장될 목적으로 특별히 크 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 한다.

### 3. Phone 클래스 다시 살펴보기 (추상화를 이용한 상속의 문제 해결하기)

- 추상화에 의존하자
  - 자식클래스가 부모클래스의 구현이 아닌 추상화에 의존하도록 변경 → 부모클래스, 자식클래스 모두 추상화에 의존하도록 변경해야 한다.
  - 상속을 도입할때 따르는 두가지 원칙
    1. 두 메소드가 유사하게 보인다면 차이점을 메소드로 추출한다. 메소드 추출을 통해 두메소드를 동일한 형태로 보이도록 만들 수 있다.
    2. 부모클래스의 코드를 하위로 내리지 말고 자식클래스의 코드를 상위로 올린다. 부모클래스의 구체적인 메서드를 자식클래스로 내리는 것보다 자식 클래스의 추상적인 메소드를 부모클래스로 올리는 것이 재사용성과 응집도 측면애서 더 뛰어난 결과를 얻을 수 있다.
- 차이를 메소드로 추출하라
  - “변하는 것으로부터 변하지 않는 것을 분리하라” or “변하는 부분을 찾고 이를 캡슐화하라”
- 중복코드를 부모클래스로 올려라.
  - 메소드를 먼저 이동시키면 컴파일 에러를 통해 해당 메서드에서 필요한 변수등을 쉽게 파악 할 수 있다.
  - 자식클래스들 사이의 공통점을 부모클래스로 옮김으로써 실제 코드를 기반으로 상속계층을 구성할 수 있다.
  - 구체적인 구현을 아래로 내리는 방식으로 현재 클래스를 구체클래스에서 추상클래스로 변경하려 한다면 작은 실수 한번으로도 구체적인 행동을 상위 클래스에 남겨놓게 된다.
- 추상화가 핵심이다.
  - 부모클래스를 추상클래스로 작성하고 실제적인 구현은 자식 클래스에서 구현함으로 인해 각각의 클래스는 단일 책임 원칙을 준수할 수 있게 된다.
  - 상속계층이 코드를 진화시키는 데 걸림돌이 도니다면 추상화를 찾아내고 상속계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩토링해야 한다. 차이점을 메서드로 추출하고 공통적인 부분은 부모클래스로 한다. → 공통되는 메소들의 구조를 부모클래스로 추상화하고 실제적인 구현은 자식 클래스에서 구현하도록 한다.
- 상속으로 인한 클래스 사이의 결합을 피할 수 있는 방법은 없다. 상속은 어떤 방식으로든 부모클래스와 자식클래스를 결합시킨다. 메서드 구현에 대한 결합은 추상메서드를 추가함으로써 어느 정도 완화할 수 있지만 인스턴스 변수에 대한 잠재적인 결합을 제거할 수 있는 방법은 없다. 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 상속계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것이다.
- 객체 생성로직의 변경에 유연하게 대응할 수 있는 다양한 방법이 존재한다. 따라서 객체생성 로직에 대한 변경을 막기보다는 핵심로직의 중복을 막고, 핵심로직은 한곳에 모아놓고 캡슐화해야 한다.
- 공통적인 핵심로직은 최대한 추상화를 해야 한다.