# chapter10. 상속과 코드 재사용

코드의 재사용

1. 상속 : 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현기법이다.
2. 합성 : 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법

### 상속을 위한 경고

1. 자식클래스의 메서드 안에서 super 참조를 이용해 부모클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거할 수 있는 방법을 찾아서 결합도를 제거해야 한다.
2. 상속받은 부모클랫의 메서드가 자식클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
3. 자식클래스가 부모클랫의 메서드를 오버라이딩할 경우 부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다.
4. 클래스를 상속하면 결합도로 인해 자식클래스와 부모클랫의 구현을 영원히 변경하지 않거나, 자식클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.

### 1. 상속과 중복코드

- DRY(Don’t Repeat Yourself) 원칙 : 모든 지싱은 시스템 내에서 단일하고 애매하지 않고 정말로 믿을 만한 표현양식을 가져야 한다.
  - **Once and Only Once원칙** 또는 **Single-Point Conrol원칙** 이라고도 함.
- 최초 요구사항으로 작성된 코드에서 변경되거나 추가된 요구사항으로 인해 기존코드를 활용하여 중복해서 작성하게 되면, 작성된 코드는 또 다시 다른 요구사항으로 인해 중복의 중복코드로 발생할 가능성이 높아진다.  이렇게 작성된 코드는 유지보수가 어려워지고 전체적인 코드의 통일성도 깨지기 쉽다. 또한 이를 어설프게 상속을 이용해서 중복코드를 제거할때에는 부모클래스에 강하게 결합될 가능성도 높아진다.

### 2. 취약한 기반 클래스 문제

- 취약한 기반 클래스 문제(Fragile Base Class Problem, Brittle Base Class Problem)
  - 상속을 사용한다면 피할 수 없는 OOP의 근본적인 취약성 : 핵심적인 기반 클래스에 대한 단순한 변경이 전체 프로그램을 불안정한 상태로 만들어버릴 수 있다.
  - 상속관계를 추가할수록 전체 시스템의 결합도가 높아진다.
  - 높은 결합도로 인해 부모 클래스를 점진적으로 개선하는 것은 어렵다.
  - 캡슐화를 약화시키고 결합도를 높인다.
  - 객체지향은 캡슐화를 통한 변경의 통제인데, 상속은 코드의 재사용을 위해 캡슐화의 잠점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.
- 불필요한 인터페이스 상속문제
  - 자바초기 버전의 사례
    1. Vector클래스를 상속받은 Stack 클래스의 사례 :: Vector의 add,remove,get 오퍼레이션을 Stack에서도 호출이 가능했다. → stack의 규칙 무시
    2. Hashtable 클래스를 상속받은 Properties 클래스의 사례 :: Hashtable의 put을 이용하면 String이외의 타입도 키로 지정가능하나, Properties는 String타입만 키로 지정이 가능하다. 그러나 Properites.put(new Object(), 123)메소드호출이 가능하나, Properties.getProperty(new Object())로 123을 읽으면 null이 반환됨. → 이는 Properties.getProperty메소드는 String이외의 Key는 null을 반환하도록 작성되었기 때문
  - 메서드 오버라이딩의 오작용 문제
    - 클래스가 상속되기를 원한다면 상속을 위해 클래스를 설계하고 문서화해야 한다. 그렇지 않은 경우에는 상속을 금지시켜야 한다.  → 메서드를 오버라이딩 가능한 메서드를 호출할 수있는 어떤 상황에 대해서도 문서화해야 한다.
    - 메서드를 오버라이딩하기 위해 문서화하는 행위는 내부구현을 공개하고 문서화해야 한다. 하지만 이는 캡술화를 위반하는 행위이다. 결론은 상속은 코드의 재사용을 위해 캡슐화를 희생해야 한다. 하지만 완벽한 캡슐화를 원한다면 코드의 재사용을 포기하거나, 상속 이외의 다른 방법을 사용해야 한다.
  - 부모클래스와 자식클래스의 동시 수정 문제
    - 서브클래스는 올바른 기능을 위해 슈퍼클랫의 세부적인 구현에 의존한다. 슈퍼클랫의 구현은 Release를 거치면서 변경될 수 있고, 그에 따라 서브클래스의 코드를 변경하지 않더라도 깨질 수 있다. 결과적으로 슈퍼클래스와 작성자가 확장될 목적으로 특별히 크 클래스를 설계하지 않았다면 서브클래스는 슈퍼클래스와 보조를 맞춰서 진화해야 한다.