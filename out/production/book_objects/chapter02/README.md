# chapter02. 객체지향 프로그래밍

1. 요구사항 정의
    1. 책에서는 온라인 영화예매 시스템을 영화, 상영, 할인(할인조건 - 순서조건/기간조건, 할인정책 - 금액할인정책/비율할인정책), 할인 적용조건 등을 알기 쉽게 풀어서 설명했다. 하지만 실제 개발업무를 진행 할때에 요구사항등에 대해서 책과 같이 설명해주는 경우는 드물다.
2. 객체지향 프로그래밍 (’객체’를 ‘지향’)
    1. 객체지향 설계의 핵심은 클래스안에 속성,메소드를 채워넣고 상속을 이용해서 코드를 재사용하는 것이 아니라, 그것을 뛰어넘어 객체간의 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에  역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것
    2. 클래스/속성/메소드등을 고민하기 이전에 객체에 초점을 맞추어야 한다.
        1. 어떤 클래스가 필요한지 보다 어떤 객체들이 필요한지 고민
            1. 클래스 = 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
        2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야함.
            1. 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 클래스로 구현
    3. 도메인 - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 **분야**
    4. 클래스 구현
        1. 클래스의 경계구분 → 경계의 명확성이 객체의 자율성을 보장한다. 또한 개발자에게 구현의 자유를 제공할 수 있다.
    5. 객체 지향
        1. 객체 = 자율적인 존재 = 상태, 행동을 가질 수 있음
        2. 캡슐화 = 데이터와 기능을 객체 내부에 함께 묶음
        3. 인터페이스와 구현의 분리 원칙 → 객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다는 원칙(객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙: 불필요한 기능의 상속/구현을 최대한 방지→ 불피요한 책임을 없앨 수 있음)
        4. 객체사이의 의존성을 적절히 관리함으로써 변경에 대한 파급효과를 제어할 수 있는 다양한 방법을 제공 → 접근제어
        5. 협력의 관점에서 어떤객체가 필요한지 파악하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성
        6. 오버라이딩, 오버로딩
        7. 생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제하면 올바른 상태를 가진 객체의 생성을 보장할 수 있다.
    6. 코드의 의존성, 실행시점의 의존성
        1. 코드의 의존성 - lazy binding
        2. 실행시점의 의존성 -early binding
        3. 코드의 의존성과 실행시점의 의존성이 다르면 다를수록 코드를 이해하기는 어려워진다. 다만 코드는 유연해지고 확장가능해진다.
        4. 유연성 vs 가독성
    7. 상속, 인터페이스
        1. 상속 - 부모클래스가 제공하는 모든 인터페이스를 자식클래스가 물려받음, 코드를 재사용하기 위해 널리 사용되는 기법 중 하나
            1. 업캐스팅 - 자식클래스가 부모 클래스를 대신하는 것
            2. 구현상속
            3. 인터페이스 상속
            4. 단점 - 상속은 캡슐화를 위반, 유연하지 못한 설계
        2. 인터페이스 - 객체가 이해할 수 있는 메세지의 목록을 정의
    8. 다형성(polymorphism) - 하나의 객체가 여러가지 타입을 가질 수 있는 것
        1. 메세지(request), 메서드(response)의 구분에서부터 다형성의 개념이 출발
        2. 지연 바인딩(lazy binding) / 동적 바인딩(dynamic binding) - **실행시점**
        3. 초기 바인딩(early binding) / 정적 바인딩(static binding) - **컴파일시점**
    9. 추상화 
        1. 요구사항의 정책을 높은 수준에서 서술할 수 있음
        2. 추상화를 이용하면 설계가 좀 더 유연해짐
        3. 추상화를 사용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있음
    10. 합성 - 상속과는 다르게 인터페이스를 통해 약하게 결합된다는 것. 상속의 캡슐화, 유연하지 못한 설계의 단점을 극복 할 수 있음


---

## 파이썬 문법

### static method  생성  
@staticmethod -> 메소드 위에 해당 어노테이션 추가

---

### 파이썬에서 자기자신의 타입을 파라미터로 입력받거나, 결과로 리턴할 때에서 TypeHint를 주면 에러가 발생하나
'from __future__ import annotations'를 하면 에러가 발생되지 않음.  
참고URL -> https://stackoverflow.com/questions/33533148/how-do-i-type-hint-a-method-with-the-type-of-the-enclosing-class

---

### 파이썬에서 interface, abstract 클래스사용
```python
from abc import *

class 클래스명(metaclass=ABCMeta):
    #인터페이스 처럼 사용
    @abstractmethod
    def 메서드명:
        raise NotImplementedError

    @abstractmethod
    def 메서드명(self):
        pass   
```

---
### Python Circular Imports?
Python Circular Imports은 한국말로는 순환 참조 정도로 번역이 됩니다. 두 개의 모듈이 서로를 참조하는 경우 발생합니다. 예를 들어 A 가 B를 참조하고, B가 A를 참조하는 경우를 말합니다.