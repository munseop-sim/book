# chapter07. 객체분해

인지 과부하(cognitive overload) - 단기/장기 기억중에 문제해결에 사용되는 것은 단기 기억. 단기기억안에 저장되어야 할 양은 정해져 있기 때문에 단순화가 필요. 이를 추상화(불필요한 정보 제거, 문제해결에 필요한 핵심만 남김)를 통해 해결할 수 있음

abstraction = 추출

추상화 (abstraction) - 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것

1. 프로시저 추상화 (procedure abstraction)
    - SW가 무엇을 해야하는지 추상화
    - 기능분해(functional decomposition) = 알고리즘 분해(algorithmic decomposition)
2. 데이터 추상화 (data abstraction)
    - SW가 무엇을 알아야 하는지 추상화
    - 방법
        - 타입 추상화 (type abstraction) = 추상 데이터 타입(Abstract Data Type)
        - 프로시저 추상화(procedure abstraction) = 객체지향(Object-Oriented)

분해(decomposition) - 문제를 작은 문제로 분해, 분해된 문제는 더 작게 분해할 수도 있다. = chunk

하향식 접근법(Top-Down Approach) 분할

- 요구사항에 대해 점점 작게 트리와 같은 구조로 기능을 분해한다.
- 필요한 기능을 먼저 고려한다. 후에 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장하는 방식을 식별한다.
- 문제점: 논리적이고 체계적인 시스템 개발절차를 제시하여 이상적으로 보이나, 실제로는 그렇지 않다.
    1. 하나의 메인함수라는 비현실적인 아이디어
        1. 대부분의 시스템에서 하나의 메인개념은 존재하지 않는다.
        2. 현대적인 System은 동등한 수준의 다양한 기능으로 구성된다.
        3. “실제 시스템에 정상(TOP)이란 존재하지 않는다.”
    2. 메인함수의 빈번한 재설계
        1. 기존의 메인함수와 동등한 레벨의 요구사항이 있을 경우 메인함수의 재설계는 불가피
        2. 기존코드의 빈번한 수정은 버그 발생확률이 높아짐을 의미한다.
    3. 비즈니스 로직과 사용자 인터페이스의 결합
        1. 기능분해과정에서 사용자 인터페이스의 관심사와 비지니스로직의 관심사를 동시에 고려하도록 강요하기 때문에 “관심사의 분리”라는 아키텍처 설계의 목적을 달성하기 어렵다.
    4. 성급하게 결정된 실행순서
        1. 시스템이 무엇(what)을 해야하는지가 아니라 어떻게(how) 동작해야하는지에 집중
        2. 중앙집중 제어 스타일 형태 → 객체지향은 함수간 호출순서가 아니라, 객체사이의 논리적 관계를 중심으로 설계를 이끌어 가야한다.
        3. 하위함수가 상위함수에 종속적이기 때문에 함수의 재사용성은 낮아질 수 밖에 없다.(강한 결합도)
    5. 데이터 변경(구조/타입)으로 인한 파급효과
- 유용한 경우 : 설계에 대해서 설명하고 문서화하기에는 용이함.

모듈(Module) 분할

- 정보은닉
- 데이터를 중심으로 시스템을 분해함
- 모듈은 서브 프로그램이라기 보다, 책임의 할당이다.
- 복잡성 : 모듈이 너무 복잡한 경우 이해하고 사용하기에 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮추도록한다.
- 변경가능성 : 변경 가능한 설계결정이 외부에 노출될 경우 실제로 변경이 발생했을때, 파급효과가 커진다.
- 문제점  : 인스턴스의 개념이 제공되지 않기 때문에 이를 극복하기 위한 방법으로 추상데이터 타입 분해가 등장
- 장점
    1. 모듈내부의 변수가 변경되더라도 모듈내부에만 영향을 미친다.
    2. 비지니스로직과 사용자 인터페이스에 대한 분리가 명확해진다.
    3. 전역변수와 전역함수를 제거함으로 네임스테피으스 오염(Namespace Pollution)을 방지 한다. 또한 이로인해 이름충돌(name collision)의 위험을 완화한다.

데이터 추상화/추상데이터 타입 분해

1. 객체기반 프로그래밍(Object-Based Programming)
2. 추상 데이터 타입을 정의 (추상데이터 = 시스템의 상태를 저장)
3. 추상데이터 타입에 적용할 수 있는 오퍼레이션 결정
4. 상속과 다형성을 지원하지 않음 (diff 클래스)
5. 타입을 추상화(diff 클래스)

클래스 분해(객체지향 분해)

1. 상속과 다형성을 지원 (diff 추상데이터)
2. 절차를 추상화, procedural abstraction (diff 추상데이터)
3. 타입을 기준으로 오퍼레이션을 묶는다.
4. 타입을 기준으로 절차를 추상화하지 않는다면 이는 객체지향 분해가 아니다.
5. 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다 = Replace Type Code with Class → 객체가 메시지를 처리할 적절한 메서드를 선택
6. 개방-폐쇄원칙(Open-Closed Principle, OCP) - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

새로운 타입을 빈번하게 추가해야 된다면 객체지향 클래스 구조가 더 유용하다. 그러나 새로운 오퍼레이션을 빈번하게 추가해야 한다면 추상데이터 타입을 선택하는 것이 현명한 판단이다.

객체가 참여할 협력을 결정하고 협력에 필여한 책임을 수행하기 위해 어떤 객체가 필요한지에 관해 고민해야 한다. 그 책임을 다양한 방식으로 수행해야 할 때만 타입 계층안에 각 절차를 추상화해야 한다. 타입계층과 다형성은 협력이라는 문맥안에서 책임을 수행하는 방법에 관해 고민한 결과물이어야 하며, 그 자체가 목적이 되어서는 안된다.